#' Calculate and add time to sunrise/sunset
#'
#' Calculate the sunrise/sunset of each sound file for the day of, the day before
#' and the day after to get the nearest sunrise to the recording.
#'
#' @param meta
#' @param aru_tz Character. Must be either "local" or a timezone listed in
#'   `OlsonNames()`. See Details.
#'
#'
#' @details Timezones. To ensure that the sunrise/sunset times are calculated
#'   correctly relative to the time of the recording, we need to know the
#'   timezone of the date/time of the recording. If ARUs were calibrated with a
#'   specific timezone before going into the field, that can be specified by
#'   using, for example, `aru_tz = "America/Toronto"`. If on the other hand each
#'   ARU was calibrated to whichever timezone was local when it was deployed use
#'   `aru_tz = "local"`. The specific timezone will be calculated individually
#'   based on the latitude and longitude of each recording.
#'
#' @return
#' @export
#'
#' @examples
calc_sun <- function(meta, aru_tz = "local") {

  # Checks
  check_data(meta, type = "meta_sites", ref = "add_sites()")
  check_tz(aru_tz)

  if(aru_tz != "local") {
    # Get timezones from location if not set globally
    tz <- dplyr::select(meta, "longitude", "latitude") |>
      dplyr::distinct() |>
      tidyr::drop_na() |>
      dplyr::mutate(
        tz = lutz::tz_lookup_coords(
          lat = .data$latitude,
          lon = .data$longitude,
          method = 'accurate'))

    m <- dplyr::left_join(meta, tz, by = c("longitude", "latitude"))
  } else {
    m <- dplyr::mutate(meta, tz = .env$aru_tz)
  }

  ss <- dplyr::select(m, "date", "tz", "longitude", "latitude") |>
    dplyr::distinct() |>
    tidyr::drop_na() |>
    tidyr::nest(dates = -"tz") |>
    dplyr::mutate(times = purrr::map2(
      .data$dates, .data$tz, ~calc_all_ss(.x, tz = .y))) |>
    tidyr::unnest("times") |>
    dplyr::select(-"dates", -"date_before", -"date_after")

  m <- dplyr::left_join(m, ss, by = c("date", "tz", "latitude", "longitude"))

  m |>
    dplyr::mutate(
      t2sr = sun_diff(.data$sunrise, .data$date_time),
      t2sr_before = sun_diff(.data$sunrise_before, .data$date_time),
      t2sr_after = sun_diff(.data$sunrise_after, .data$date_time),
      t2ss = sun_diff(.data$sunset, .data$date_time),
      t2ss_before = sun_diff(.data$sunset_before, .data$date_time),
      t2ss_after = sun_diff(.data$sunset_after, .data$date_time),
      doy = lubridate::yday(.data$date),
      t2sr = pmin(.data$t2sr, .data$t2sr_before, .data$t2sr_after),
      t2ss = pmin(.data$t2ss, .data$t2ss_before, .data$t2ss_after)) |>
    dplyr::select(dplyr::all_of(names(meta)), "tz", "t2sr", "t2ss")
}

sun_diff <- function(t1, t2) {
  abs(as.numeric(difftime(t1, t2, units = "mins")))
}

#' Calculate sunrise and sunset and time to sunset for BarLT recordings
#'
#'
#'
#' @param gps_locations data frame generated by process_gps_barlt or process_gps_SM
#' @param wav_names_log data frame generated by parse_datetimes
#'
#' @return returns a data frame with time to sunrise
#'
#' @noRd
calc_all_ss <- function(dates, tz){

  ss_day_of <- calc_ss(dates, tz)

  ss_day_before <- dates |>
    dplyr::mutate(date = date - lubridate::days(1)) |>
    calc_ss(tz, suffix = "_before") |>
    dplyr::bind_cols(date = dates$date)

  ss_day_after <- dates |>
    dplyr::mutate(date = date + lubridate::days(1)) |>
    calc_ss(tz, suffix = "_after") |>
    dplyr::bind_cols(date = dates$date)

  dplyr::left_join(ss_day_of, ss_day_before, by = c("date", "latitude", "longitude")) |>
    dplyr::left_join(ss_day_after, by = c("date", "latitude", "longitude"))
}


#' Calculate sunrise sunset
#'
#' A wrapper around suncalc::getSunlightTimes to ensure
#'    timezones and lat/lon are correct.
#'
#' @param .data data frame from prep_sunrise_sunset
#' @param var_day variable from .data to use as date to calculate sunrise
#'
#' @return Returns a data frame with sunrise and sunset
#'
#' @noRd
calc_ss <- function(dates, tz, suffix = ""){

  dplyr::rename(dates, "lat" = "latitude", "lon" = "longitude") |>
    suncalc::getSunlightTimes(data = _, keep = c("sunrise", "sunset"), tz = tz) |>
    dplyr::mutate(sunrise = lubridate::force_tz(.data$sunrise, "UTC"),
                  sunset = lubridate::force_tz(.data$sunset, "UTC")) |>
    dplyr::rename(
      "date{suffix}" := "date",
      "sunrise{suffix}" := "sunrise",
      "sunset{suffix}" := "sunset",
      "latitude" = "lat",
      "longitude" = "lon"
    ) |>
    tibble::as_tibble()
}
